from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import send_message, run_on_queue
from ui.settings import Header, Input
from java.util import Locale
import time
import re

__id__ = "mathplug"
__name__ = "MathHelper"
__description__ = "–ò—Å–ø–æ–ª—å–∑—É–π .math –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏–π"
__author__ = "@RussianDSG & @nedenchiz"
__version__ = "1.0"
__icon__ = "üßÆ"
__min_version__ = "11.12.0"

class LocalizationManager:
    def __init__(self):
        self.language = "ru"

    def set_language(self, lang):
        if lang in self.strings:
            self.language = lang

    def get_string(self, string):
        return self.strings[self.language][string]

    strings = {
        "ru": {
            "GUIDE": "üßÆ –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä v1.0\n\nüìù –ö–æ–º–∞–Ω–¥—ã:\n.math <–≤—ã—Ä–∞–∂–µ–Ω–∏–µ> ‚Äì –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è\n\n–ü—Ä–∏–º–µ—Ä—ã:\n.math 2+2\n.math 15*3\n.math (10+5)/3\n.math sqrt(16)\n\nüìä –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏:\n+ —Å–ª–æ–∂–µ–Ω–∏–µ, - –≤—ã—á–∏—Ç–∞–Ω–∏–µ\n* —É–º–Ω–æ–∂–µ–Ω–∏–µ, / –¥–µ–ª–µ–Ω–∏–µ\n** –≤–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å\n% –æ—Å—Ç–∞—Ç–æ–∫ –æ—Ç –¥–µ–ª–µ–Ω–∏—è\n\nüî¢ –§—É–Ω–∫—Ü–∏–∏:\nsqrt(x) ‚Äì –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–π –∫–æ—Ä–µ–Ω—å\nabs(x) ‚Äì –º–æ–¥—É–ª—å —á–∏—Å–ª–∞\nround(x) ‚Äì –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ\n",
            "USAGE": "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: .math <–≤—ã—Ä–∞–∂–µ–Ω–∏–µ>\n–ü—Ä–∏–º–µ—Ä: .math 2+2*3",
            "RESULT": "–†–µ–∑—É–ª—å—Ç–∞—Ç: {} = {}",
            "ERROR": "–û—à–∏–±–∫–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è: {}",
            "SYNTAX_ERROR": "–°–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏",
            "DIVISION_ZERO": "–î–µ–ª–µ–Ω–∏–µ –Ω–∞ –Ω–æ–ª—å –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ",
            "LANG_SET": "–Ø–∑—ã–∫ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω –Ω–∞ {lang}",
        },
        "en": {
            "GUIDE": "üßÆ Calculator v1.0\n\nüìù Commands:\n.math <expression> ‚Äì evaluate mathematical expression\n\nExamples:\n.math 2+2\n.math 15*3\n.math (10+5)/3\n.math sqrt(16)\n\nüìä Supported operations:\n+ addition, - subtraction\n* multiplication, / division\n** exponentiation\n% modulo\n\nüî¢ Functions:\nsqrt(x) ‚Äì square root\nabs(x) ‚Äì absolute value\nround(x) ‚Äì rounding\n",
            "USAGE": "Usage: .math <expression>\nExample: .math 2+2*3",
            "RESULT": "Result: {} = {}",
            "ERROR": "Calculation error: {}",
            "SYNTAX_ERROR": "Syntax error in expression",
            "DIVISION_ZERO": "Division by zero is not possible",
            "LANG_SET": "Language set to {lang}",
        }
    }

locali = LocalizationManager()

class CalculatorPlugin(BasePlugin):
    def on_plugin_load(self):
        self.add_on_send_message_hook()

    def create_settings(self):
        return [
            Header("Calculator v1.0 settings"),
            Input(key="calc_precision", text="Decimal precision", default="2"),
        ]

    def safe_eval(self, expression):
        try:
            expression = expression.replace(' ', '')
            
            if any(char in expression for char in ['import', 'exec', 'eval', 'open', 'file', 'os', 'sys', '__']):
                raise ValueError("Invalid expression")
            
            expression = expression.replace('sqrt', 'math.sqrt')
            expression = expression.replace('abs', 'math.fabs')
            expression = expression.replace('round', 'round')
            
            import math
            
            result = eval(expression, {'math': math, '__builtins__': {}})
            
            try:
                precision = int(self.get_setting("calc_precision") or "2")
            except:
                precision = 2
                
            if isinstance(result, float):
                if result.is_integer():
                    return int(result)
                else:
                    return round(result, precision)
            return result
            
        except ZeroDivisionError:
            raise ValueError(locali.get_string("DIVISION_ZERO"))
        except SyntaxError:
            raise ValueError(locali.get_string("SYNTAX_ERROR"))
        except Exception as e:
            raise ValueError(str(e))

    def on_send_message_hook(self, account, params):
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()

        text = params.message.strip()

        if text.startswith(".guide"):
            params.message = locali.get_string("GUIDE")
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        if text.startswith(".lang"):
            parts = text.split()
            if len(parts) > 1 and parts[1] in ["ru", "en"]:
                locali.set_language(parts[1])
                params.message = locali.get_string("LANG_SET").format(lang=parts[1])
            else:
                params.message = "Usage: .lang ru/en"
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        if text.startswith(".math"):
            try:
                parts = text.split(maxsplit=1)
                if len(parts) < 2:
                    params.message = locali.get_string("USAGE")
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)
                
                expression = parts[1]
                result = self.safe_eval(expression)
                
                params.message = locali.get_string("RESULT").format(expression, result)
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
                
            except ValueError as e:
                params.message = locali.get_string("ERROR").format(str(e))
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
            except Exception:
                params.message = locali.get_string("SYNTAX_ERROR")
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

        return HookResult()
